# C/C++

## const 关键字

1. 修饰变量，说明该变量不可以被改变
2. 修饰指针，const 在 `*` 之前为指向常量的指针，const 在 `*` 之后为指针常量
3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

### 类中的使用

1. 常成员变量，只能在初始化列表中赋值
2. 常成员函数，不得修改类中的任何数据成员的值
3. 常对象，只能调用常成员函数、更新常成员变量

### 参数中使用

1. `const int var` 传过来的参数在函数中不可变
2. `const char* var` 参数指针所指内容为常量
3. `char* const var` 参数指针为常指针
4. `const int& var` 引用参数在函数内为常量

### 返回值中使用

1. `const int` 返回一个常量
2. `const int*` 返回一个指向常量的指针变量
3. `int* const` 返回一个指向变量的常指针

## static 关键字

修饰普通方法、变量

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。

修饰成员方法、变量

1. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
2. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

## this指针

this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
  
### 特点

1. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
2. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
3. this 指针被隐含地声明为: `ClassName -const this`，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：`const ClassName- const`，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）
4. this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。

显示引用this指针场景:

- 为实现对象的链式引用
- 为避免对同一对象进行赋值操作
- 在实现一些数据结构时，如 list

## inline 内联函数

### 特征

1. 相当于把内联函数里面的内容写在调用内联函数处
2. 相当于不用执行进入函数的步骤，直接执行函数体
3. 相当于宏，却比宏多了类型检查，真正具有函数特性
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，类外需要显示内联

### 编译器对inline函数的处理

- 将 inline 函数体复制到 inline 函数调用点处，为所有inline函数中的局部变量分配内存空间
- 将inline函数的输入参数和返回值映射到调用方法的局部变量空间中

优点：

- 省去栈帧开辟和回收等过程
- 内联函数相比宏函数来说会做安全检查或自动类型转换
- 内联函数运行时可调试，宏不可以

缺点：代码膨胀，是否内敛程序员不可控

虚函数可以是内联函数么？

虚函数可以是内联函数，内联可以修饰虚函数，但是当虚函数表现多态性时不能内联

## struct 和 class

最本质的一个区别就是默认的访问控制，默认的继承访问权限。struct 是 public 的，class 是 private 的

struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

## 其他关键字或方法

### assert() 断言

### sizeof()

- sizeof 对数组，得到整个数组所占空间大小
- sizeof 对指针，得到指针本身所占空间大小

### #pragma pack(n)

- 设定结构体、联合以及类成员变量以n字节方式对齐

### 位域

- 类可以将其非静态数据成员定义为位域，在一个位域中含有一定数量的二进制位，当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域

### extern "C"

- 作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

### using

- 尽量少使用 using 提示
- 应该多使用 using 声明

### explicit

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换

### decltype

- 用于检查实体的声明类型或表达式的类型及值分类

## friend 友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

## union 联合

定义：联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态

特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的
  
## volatile 关键字

- 易变性：下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取
- 不可优化的：volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行
- 顺序性：能够保证 volatile 变量间的顺序性，编译器不会进行乱序优化，volatile变量和非volatile变量的顺序编译器不能保证，可能会进行乱序优化

## ::范围解析运算符

1. 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
2. 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
3. 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

## enum 枚举类型

限制作用域的枚举类型

```cpp
enum class open_modes { input, output, append }
```

不限定作用域的枚举类型

```cpp
enum color { red, yellow, green }; enum { floatPrec = 6, doublePrec = 10 };
```

## 引用

- 左值表达式：表示的是一个对象的身份，左值匹配时，优先匹配l-value，再匹配const value
- 右值表达式：表示的是一个对象的值，右值匹配时，会优先匹配r-value，再匹配const value
- 左值引用，常规引用，一般表示对象的身份
- 右值引用，右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

目的：

- 为了支持移动操作，新标准引入右值引用，可以消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

区分左值和右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值

## 初始化

### 成员初始化列表

更高效：少了一次调用默认构造函数的过程

必须使用的场景：

- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
- 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
- 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。
  
### initializer_list 列表初始化

用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数

## 面向对象

### 虚函数表

定义：为了支持虚函数机制，编译器为每一个拥有虚函数的类的实例创建了一个虚函数表（virtual table），这个表中有许多的槽（slot），每个槽中存放的是虚函数的地址。虚函数表解决了继承、覆盖、添加虚函数的问题，保证其真实反应实际的函数

定义一个Base类，其中有三个虚函数 vptr指针指位于对象空间的最前面  其中包含了三个虚函数的地址

#### 单继承时的虚函数表

1. 无虚函数覆盖

```cpp
class Base
{
public:
    virtual void x() { cout << "Base::x()" << endl; }
    virtual void y() { cout << "Base::y()" << endl; }
    virtual void z() { cout << "Base::z()" << endl; }
};

class Derive : public Base
{
public:
    virtual void x1() { cout << "Derive::x1()" << endl; }
    virtual void y1() { cout << "Derive::y1()" << endl; }
    virtual void z1() { cout << "Derive::z1()" << endl; }
};
```

子类实例的虚函数表中，虚函数地址顺序为：父类的虚函数，子类的虚函数

2. 有虚函数覆盖

```cpp
class Base
{
public:
    virtual void x() { cout << "Base::x()" << endl; }
    virtual void y() { cout << "Base::y()" << endl; }
    virtual void z() { cout << "Base::z()" << endl; }
};

class Derive : public Base
{
public:
    virtual void x() { cout << "Derive::x()" << endl; }  // 重写
    virtual void y1() { cout << "Derive::y1()" << endl; }
    virtual void z1() { cout << "Derive::z1()" << endl; 
};
```

子类实例的虚函数表中，虚函数地址顺序为：子类重写父类的虚函数，父类没有被重写的虚函数，子类自身的虚函数

#### 多重继承时的虚函数表

1. 无虚函数覆盖

```cpp
class Base1
{
public:
    virtual void x() { cout << "Base1::x()" << endl; }
    virtual void y() { cout << "Base1::y()" << endl; }
    virtual void z() { cout << "Base1::z()" << endl; }
};

class Base2
{
public:
    virtual void x() { cout << "Base2::x()" << endl; }  
    virtual void y() { cout << "Base2::y()" << endl; }
    virtual void z() { cout << "Base2::z()" << endl; }
};

class Derive : public Base1, public Base2
{
public:
    virtual void x1() { cout << "Derive::x1()" << endl; }  
    virtual void y1() { cout << "Derive::y1()" << endl; }
};
```

子类实例中，每一个父类对应一个虚函数表，子类中新增的虚函数放到第一个虚函数表的后面

2. 有虚函数覆盖

```cpp
class Base1
{
public:
    virtual void x() { cout << "Base1::x()" << endl; }
    virtual void y() { cout << "Base1::y()" << endl; }
    virtual void z() { cout << "Base1::z()" << endl; }
};

class Base2
{
public:
    virtual void x() { cout << "Base2::x()" << endl; }  
    virtual void y() { cout << "Base2::y()" << endl; }
    virtual void z() { cout << "Base2::z()" << endl; }
};

class Derive : public Base1, public Base2
{
public:
    virtual void x() { cout << "Derive::x()" << endl; }     // 重写
    virtual void y1() { cout << "Derive::y1()" << endl; }
};
```

- 子类实例中，每一个父类对应一个虚函数表
- 子类重写的虚函数替换到每一个父类虚函数表中
- 子类未重写的虚函数放到第一个虚函数表的后面

### 虚析构函数

虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

Shape是父类，Circle是子类，因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏

## 三大特性

封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏

- public 成员：可以被任意实体访问
- protected 成员：只允许被子类及本类的成员函数访问
- private 成员：只允许被本类的成员函数访问

```txt
基类变量类型   继承类型    子类变量类型
public         public      public
protected                  protected
private                    不可继承
-------------------------------------
public         protected   protected
protected                  protected
private                    不可继承
-------------------------------------
publlic       private      private
protected                  private
private                    不可继承
```

继承：基类（父类）-> 派生类（子类）

多态：

核心：引用或指针的静态类型和动态类型不同这一事实 正是 C++语言支持多态性的根本所在

定义：

- 多态，即多种状态（形态）。将基类的指针或引用绑定到子类的实例，然后通过基类的指针或引用调用实际子类的成员函数
- 多态是以封装和继承为基础的。

实现：

- 重载多态（编译期）：函数重载、运算符重载
- 子类型多态（运行期）：虚函数
- 参数多态性（编译期）：类模板、函数模板
- 强制多态（编译期/运行期）：基本类型转换、自定义类型转换

哪些函数不能声明为虚函数？

- 普通函数（非类成员函数）不能是虚函数
- 静态函数（static）不能是虚函数
- 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
- 内联函数不能是表现多态性时的虚函数

### 抽象类，接口类，聚合类

- 抽象类
  - 含有纯虚函数的类
- 接口类
  - 仅含有纯虚函数的抽象类
- 聚合类
  - 用户可以直接访问其成员，并且具有特殊的初始化语法形式

### 虚函数和纯虚函数

- 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做
- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。

### 智能指针

- shared_ptr
  - 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源
- unique_ptr
  - unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针
- weak_ptr
  - weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空
- auto_ptr（被 C++11 弃用）

### 强制类型转换运算符

- static_cast
  - 用于非多态类型的转换
  - 不执行运行时类型检查（转换安全性不如 dynamic_cast）
  - 通常用于转换数值数据类型（如 float -> int）
  - 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）
- dynamic_cast
  - 用于多态类型的转换
  - 执行行运行时类型检查
  - 只适用于指针或引用
  - 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
  - 可以在整个类层次结构中移动指针，包括向上转换、向下转换
- const_cast
  - 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）
- reinterpret_cast
  - 用于位的简单重新解释
  - 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
  - 允许将任何指针转换为任何其他指针类型（如 char- 到 int- 或 One_class- 到 Unrelated_class- 之类的转换，但其本身并不安全）
  - 也允许将任何整数类型转换为任何指针类型以及反向转换。
  - reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。
  - reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。
- bad_cast
  - 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。
