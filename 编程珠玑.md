# 编程珠玑

## 第二章 算法


2.1 三个问题

- A：（二分法）

`给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中一32位整数。`(二分搜索通过重复探索当前范围的中点来定位对象)

1. 在文件中至少存在这样一个数？
    - 32位整数一共有4 294 967 296个这样的数
2. 如果有足够的内存，如何处理？
    - 采用位图技术 使用 536870912个八位字节形成位图表示已经看到的整数
3. 如果内存不足，仅可以用文件来进行处理，如何处理？
    - 从整数的32位表示的角度来看，当我们读入40亿个数（最多，可以分多次读写）把起始位为0的写入到一个文件中，把起始位为1的学如到另一个文件中，这两个文件必然有一个最多包含20亿个数把它作为下一次输入

- B：（递归与抽象）

`将一个n元一维向量向左选旋转i个位置,字符串循环移位,比如abcdef 左移三位,则变成defabc`

```c++
void reverStr(string& str, int begin, int end) {
    while (begin < end) {
        swap(str[begin], str[end]);
        begin++;
        end--;
    }
} 

void rev(string& str, int i) {
    reverStr(str, 0, i - 1);
    reverStr(str, i, str.size() - 1);
    reverStr(str, 0, str.size() - 1);
}
```

- C：（离散化思想）

`给定一个英语字典，找出其中的所有变位词集合,比如abc bca cba互为变位词。任何一种考虑单词中所有单词的排序的方法都注定要失败,原始问题简化为两个子问题：选择标识和集中具有相同标识的单词`

```c++
void addWord(map<string, vector<string> >& dict, string word) {
    string w = word;
    sort(w.begin(), w.end());
    dict[w].push_back(word);
}
void lookup(map<string, vector<string> >& dict, string word) {
    sort(word.begin(), word.end());
    if (dict.count(word) == 0) {
        cout << "no such result" << endl;
        return;
    }

    for (auto item : dict[word]) {
        cout << item << endl;
    }
}
```

### 课后习题

8. 给定一个n元实数集合，一个实数t和一个整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t。

解决办法：

- 快速排序：时间复杂度nlog(n)
- 堆排序：在这个题目中，我们需要的只是前k个最小元素，时间复杂度为nlog(k)

```c++
vector<int> TopkWithHeap(vector<int>& vec, int k) {
    if (k > vec.size()) {
        return vec;
    }
    priority_queue<int, vector<int>, greater<int> > minHeap;
    for (int i = 0; i < k; i++) {
        minHeap.push(vec[i]);
    }
    for (int i = k; i < vec.size(); i++) {
        if (vec[i] < minHeap.top()) {
            minHeap.pop();
            minHeap.push(vec[i]);
        }
    }
    vector<int> res;
    for (int i = 0; i < k; i++) {
        res.push_back(minHeap.top());
        minHeap.pop();
    }
    for (auto item : res) {
        cout << item << " ";
    }
    cout << endl;
    return res;
}
```

- 作者要求：时间复杂度达到o(n)

`首先在数组中选取一个数centre作为枢纽，将比centre小的数，放到centre的前面将比centre大的数，放到centre的后面。如果此时centre的位置刚好为k，则centre为第k个最小的数；如果此时centre的位置比k前，则第k个最小数一定在centre后面，递归地在其右边寻找；如果此时centre的位置比k后，则第k个最小数一定在centre后面，递归地在其左边寻找`

```c++
int partition(vector<int>& vec, int low, int high) {
    if (vec.empty())
        return -1;
    int flag = vec[low];
    while (low < high) {
        while (low < high && vec[high] >= flag) high--;
        vec[low] = vec[high];
        while (low < high && vec[low] <= flag) low++;
        vec[high] = vec[low];
    }
    vec[low] = flag;
    return low;
}

int getTopk(vector<int>& vec, int k) {
    if (vec.empty())
        return -1;
    int low = 0;
    int high = vec.size() - 1;
    while (high > low) {
        int index = partition(vec, low, high);
        if (k - 1 > index) {
            low = index + 1;
        }
        else if (k - 1 < index) {
            high = index - 1;
        }
        else {
            return index;
        }
    }
}
```

- 位图去重

## 第三章 数据决定程序结构

`程序员在节省空间方面无计可施时，将自己从代码中解放出来，退回起点并集中心力研究数据，常常能有奇效，（数据的）表示形式时程序设计的根本`

- 使用数组重新编写重复代码
- 封装复杂结构
- 尽可能使用高级工具
- 从数据得出程序的结构

## 第四章 编写正确的程序

`编程技巧仅仅是编写正确程序的很小的一部分，大部分内容还是问题定义、算法设计、数据结构的选择`

### 循环不变式

    1. 初始：循环第一次迭代开始之前，我们的描述和假设必须正确
    2. 维护：在某次迭代时正确的，在下次迭代还是正确的
    3. 终止：循环可以终止，并返回正确的结果

### 二分查找值为key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1;
else if (data[mid] < key) left = mid + 1;
else if (data[mid] == key) return mid;
```

- 终止：每次重要没有找到的话，待查区间必定会减少至少一个长度的，所以我们的程序必定会正确结束，不会出现死循环的情况，如果left>right的话，返回-1

```c++
int BinarySerch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid - 1;
        else if (data[mid] < key) left = mid + 1;
        else return mid;
    }
    return -1;
}
```

### 二分查找key第一次出现的下标 可能重复 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1 //1 查找范围缩小了right-mid+1
else if (data[mid] < key) left = mid + 1 //2 查找范围缩小了mid-left+1
else right = mid; //3 当相同的时候，我们要找的是第一次出现的下标，显然第一次出现的下标必然在left-mid之间，查找区间缩小了right-mid
//1,3 可以合并，合并起来可以减少代码量和分支语句，虽然影响搜索的精度，但是不影响结果
```

- 终止：当left=right时，我们的待查区域缩小量始终为：right-mid = right - right = 0，这种情况下会导致死循环，这是我们就要对循环的条件进行修改：
  - left = right - 1时，mid始终等于left，查找范围会缩小，可以正确运行
  - left = right时，mid始终等于left和right，查找范围是0，会不正确终止
  - 根据以上两种情况，我们只要让循环条件变为left < right即可，之后我们对data[left]判断

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (data[mid] < key) left = mid + 1;
        else right = mid;
    }
    return data[left] == key ? left : (data[right] == key ? right : -1);
}
```

### 二分查找key最后一次出现的下标 可能重复 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1; //1 查找范围缩小了right-mid+1
else if (data[mid] < key) left = mid + 1; //2 查找范围缩小了mid-left+1
else left = mid; //3 相等时，我们要查找的是最后一个元素，先让最后一个key的下标必然在mid-right之间，查找范围缩小mid-right
//同上我们可以合并2，3，减少代码量，我们始终保证了待查元素落在left-right范围内
```

-终止：当left=right-1 或者left=right时，mid始终等于left，那么对于判断3容易出现死循环，终止条件修正为left< right-1 ,最后对left，right判断

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid - 1;
        else left = mid;
    }
    return data[right] == key ? right : (data[left] == key ? left : -1);
}
```

### 二分查找刚好小于key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] >= key) right = mid - 1; //1 显然小于的话，我们的待查元素必然在mid-right中间，那么缩小的区域大小就是mid-left
else left = mid; //2 缩小范围是 right-mid+1
```

-终止：对于1来说，如果left=right-1或left=right会出现死循环，所以修改终止条件为left-right-1

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (data[mid] >= key) right = mid - 1;
        else left = mid;
    }
    return data[right] < key ? right : (data[left] < key ? left : -1);
}
```

### 二分查找刚好大于key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if(data[mid] > key) right = mid;
else left = mid + 1;
```

- 终止：对于情况left==right来说，容易出现死循环的情况，修改循环条件为left < right

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid;
        else left = mid + 1;
    }
    return data[left] > key ? left : (data[right] > key ? right : -1);
}
```