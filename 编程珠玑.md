# 编程珠玑

## 第二章 算法


2.1 三个问题

- A：（二分法）

`给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中一32位整数。`(二分搜索通过重复探索当前范围的中点来定位对象)

1. 在文件中至少存在这样一个数？
    - 32位整数一共有4 294 967 296个这样的数
2. 如果有足够的内存，如何处理？
    - 采用位图技术 使用 536870912个八位字节形成位图表示已经看到的整数
3. 如果内存不足，仅可以用文件来进行处理，如何处理？
    - 从整数的32位表示的角度来看，当我们读入40亿个数（最多，可以分多次读写）把起始位为0的写入到一个文件中，把起始位为1的学如到另一个文件中，这两个文件必然有一个最多包含20亿个数把它作为下一次输入

- B：（递归与抽象）

`将一个n元一维向量向左选旋转i个位置,字符串循环移位,比如abcdef 左移三位,则变成defabc`

```c++
void reverStr(string& str, int begin, int end) {
    while (begin < end) {
        swap(str[begin], str[end]);
        begin++;
        end--;
    }
} 

void rev(string& str, int i) {
    reverStr(str, 0, i - 1);
    reverStr(str, i, str.size() - 1);
    reverStr(str, 0, str.size() - 1);
}
```

- C：（离散化思想）

`给定一个英语字典，找出其中的所有变位词集合,比如abc bca cba互为变位词。任何一种考虑单词中所有单词的排序的方法都注定要失败,原始问题简化为两个子问题：选择标识和集中具有相同标识的单词`

```c++
void addWord(map<string, vector<string> >& dict, string word) {
    string w = word;
    sort(w.begin(), w.end());
    dict[w].push_back(word);
}
void lookup(map<string, vector<string> >& dict, string word) {
    sort(word.begin(), word.end());
    if (dict.count(word) == 0) {
        cout << "no such result" << endl;
        return;
    }

    for (auto item : dict[word]) {
        cout << item << endl;
    }
}
```

### 习题

8. 给定一个n元实数集合，一个实数t和一个整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t。

解决办法：

- 快速排序：时间复杂度nlog(n)
- 堆排序：在这个题目中，我们需要的只是前k个最小元素，时间复杂度为nlog(k)

```c++
vector<int> TopkWithHeap(vector<int>& vec, int k) {
    if (k > vec.size()) {
        return vec;
    }
    priority_queue<int, vector<int>, greater<int> > minHeap;
    for (int i = 0; i < k; i++) {
        minHeap.push(vec[i]);
    }
    for (int i = k; i < vec.size(); i++) {
        if (vec[i] < minHeap.top()) {
            minHeap.pop();
            minHeap.push(vec[i]);
        }
    }
    vector<int> res;
    for (int i = 0; i < k; i++) {
        res.push_back(minHeap.top());
        minHeap.pop();
    }
    for (auto item : res) {
        cout << item << " ";
    }
    cout << endl;
    return res;
}
```

- 作者要求：时间复杂度达到o(n)

`首先在数组中选取一个数centre作为枢纽，将比centre小的数，放到centre的前面将比centre大的数，放到centre的后面。如果此时centre的位置刚好为k，则centre为第k个最小的数；如果此时centre的位置比k前，则第k个最小数一定在centre后面，递归地在其右边寻找；如果此时centre的位置比k后，则第k个最小数一定在centre后面，递归地在其左边寻找`

```c++
int partition(vector<int>& vec, int low, int high) {
    if (vec.empty())
        return -1;
    int flag = vec[low];
    while (low < high) {
        while (low < high && vec[high] >= flag) high--;
        vec[low] = vec[high];
        while (low < high && vec[low] <= flag) low++;
        vec[high] = vec[low];
    }
    vec[low] = flag;
    return low;
}

int getTopk(vector<int>& vec, int k) {
    if (vec.empty())
        return -1;
    int low = 0;
    int high = vec.size() - 1;
    while (high > low) {
        int index = partition(vec, low, high);
        if (k - 1 > index) {
            low = index + 1;
        }
        else if (k - 1 < index) {
            high = index - 1;
        }
        else {
            return index;
        }
    }
}
```

- 位图去重

## 第三章 数据决定程序结构

`程序员在节省空间方面无计可施时，将自己从代码中解放出来，退回起点并集中心力研究数据，常常能有奇效，（数据的）表示形式时程序设计的根本`

- 使用数组重新编写重复代码
- 封装复杂结构
- 尽可能使用高级工具
- 从数据得出程序的结构

## 第四章 编写正确的程序

`编程技巧仅仅是编写正确程序的很小的一部分，大部分内容还是问题定义、算法设计、数据结构的选择`

### 循环不变式

    1. 初始：循环第一次迭代开始之前，我们的描述和假设必须正确
    2. 维护：在某次迭代时正确的，在下次迭代还是正确的
    3. 终止：循环可以终止，并返回正确的结果

### 二分查找值为key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1;
else if (data[mid] < key) left = mid + 1;
else if (data[mid] == key) return mid;
```

- 终止：每次重要没有找到的话，待查区间必定会减少至少一个长度的，所以我们的程序必定会正确结束，不会出现死循环的情况，如果left>right的话，返回-1

```c++
int BinarySerch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid - 1;
        else if (data[mid] < key) left = mid + 1;
        else return mid;
    }
    return -1;
}
```

### 二分查找key第一次出现的下标 可能重复 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1 //1 查找范围缩小了right-mid+1
else if (data[mid] < key) left = mid + 1 //2 查找范围缩小了mid-left+1
else right = mid; //3 相等时，我们要找的是第一次出现的下标，显然第一次出现的下标必然在left-mid之间，查找区间缩小了right-mid
//1,3 可以合并，合并起来可以减少代码量和分支语句，虽然影响搜索的精度，但是不影响结果
```

- 终止：当left=right时，我们的待查区域缩小量始终为：right-mid = right-right = 0，这种情况下会导致死循环，这是我们就要对循环的条件进行修改：
  - left = right - 1时，mid始终等于left，查找范围会缩小，可以正确运行
  - left = right时，mid始终等于left和right，查找范围是0，会不正确终止
  - 根据以上两种情况，我们只要让循环条件变为left < right即可，之后我们对data[left]判断

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (data[mid] < key) left = mid + 1;
        else right = mid;
    }
    return data[left] == key ? left : (data[right] == key ? right : -1);
}
```

### 二分查找key最后一次出现的下标 可能重复 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1; //1 查找范围缩小了right-mid+1
else if (data[mid] < key) left = mid + 1; //2 查找范围缩小了mid-left+1
else left = mid; //3 相等时，我们要查找的是最后一个元素，先让最后一个key的下标必然在mid-right之间，查找范围缩小mid-right
//同上我们可以合并2，3，减少代码量，我们始终保证了待查元素落在left-right范围内
```

- 终止：当left=right-1 或者left=right时，mid始终等于left，那么对于判断3容易出现死循环，终止条件修正为left< right-1 ,最后对left，right判断

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid - 1;
        else left = mid;
    }
    return data[right] == key ? right : (data[left] == key ? left : -1);
}
```

### 二分查找刚好小于key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] >= key) right = mid - 1; //1 显然小于的话，我们的待查元素必然在left-mid之间
else left = mid; //2 缩小范围是 right-mid+1
```

- 终止：对于1来说，如果left=right-1或left=right会出现死循环，所以修改终止条件为left-right-1

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (data[mid] >= key) right = mid - 1;
        else left = mid;
    }
    return data[right] < key ? right : (data[left] < key ? left : -1);
}
```

### 二分查找刚好大于key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if(data[mid] <= key) left = mid + 1; //1 大于的话，我们的待查元素必然mid-right之间
else right = mid;
```

- 终止：对于情况left==right来说，容易出现死循环的情况，修改循环条件为left < right

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid;
        else left = mid + 1;
    }
    return data[left] > key ? left : (data[right] > key ? right : -1);
}
```

### 习题

咖啡罐问题：给定一个盛有一些黑豆和白豆的咖啡罐，以及一些额外的黑豆，重复下面过程，直到罐中仅剩一颗豆子：

- 从罐子中随机取两颗豆子，如果颜色相同，将它们都扔掉，并放入一颗黑豆
- 如果颜色不同，将黑豆扔掉，把白豆放回罐中
- 证明该过程会结束，左后留在罐中的豆子颜色与最初罐中白色豆子和黑色豆子有何函数关系

答：由于每一步都使得豆子减少1粒，所以该过程能够结束。每一步都从拿掉0个或者2个白豆，所以白豆个数的奇偶性不变。因此只有当最初白豆个数是奇数时，最后留下的豆子才可能是白色的

## 第五章 编程小事

### 断言的艺术

脚手架函数是用于输出中间结果的各种函数，通过它们验证程序的每一步的处理结果是否符合预期。

弱断言，仅仅重复了if语句的条件

```c++
else if (x[m] == t) {
    assert(x[m] == t);
    return m;
} else
```

加强的断言，断言其返回值在输入范围内

```c++
assert(0 <= m && m < n && x[m] == t);
```

二分搜索时，断言数组是排序的，assert(sorted())，但是必须注意由于该测试开销较大，我们应该只能在所有的搜索之前进行一次测试，将该测试包含在住主循环之中会导致二分搜索的运行时间正比于nlogn

```c++
int sorted() {
    for (int i = 0; i < n - 1; i++) {
        if (x[i] > x[i - 1])
            return 0;
    }
    return 1;
}
```

## 第六章 程序性能分析

### 优化程序的几个方面

- 算法和数据结构
- 算法调优
- 数据结构重组
- 代码调优
- 硬件

计算机系统中最廉价、最快速且最可靠的元件是根本不存在的

如果仅需要较小的加速，就对效果最佳的层面做改进

如果需要较大的加速，就对多个层面做改进

## 第七章 粗略估计

### 快速检验

1. 和式中各项的纲量必须相同
2. 乘积的纲量是各乘数纲量的乘积

### 经验法则

72法则，假设以年利率r%投资一笔钱y年，如果r*y=72，那么你的投资差不多才会翻倍

<img src="http://www.forkosh.com/mathtex.cgi? $\pi$">
秒就是一个纳世纪

### 性能估计

耗时的空间分配器，1-12字节的记录要消耗48字节的内存空间，13-28字节的记录要消耗64字节的内存空间

### 安全系数

为了补偿知识局限，在估算实时软件系统性能的时候，以2，4，6的系数来降低对性能的估计，在作出可靠性/可用性保证时，给出一个比我们认为能达到的目标差10倍的结果，在估算规模\开销和时间进度时，给出一个比我们认为能达到的目标差10倍的结果

### Little定律

`系统中物体的平均数量 = 物体离开系统的平均速率 * 每个物体在系统中停留的平均时间`

比如一个地方可以容纳60人，每个人在里面逗留3小时，因此我们进入这个场所的速率大概是每小时20人，现在队伍前面还有20人，这也就意味着我们需要等待大约一小时

`任何事情都应尽量简单，但不宜过于简单`

## 第八章 算法设计技术

### 问题及简单算法

问题：输入为具有n个浮点数的向量x，输出为输入向量的任何连续子向量中的最大和。例如如果输入向量包含下面十个元素
<center> | 31 | -41 | 59 | 26 | -53 | 58 | 97 | -93 | -23 | 84 | </center>

那么该程序的输出为x[2..6]的总和，即187，当所有数都是正数时，此时最大的子向量就是整个输入向量，当所有数都是负数的时候，总和最大的子向量就是空向量

浅显的程序就是对所有满足 $0<=i<=j<n$ 整数对进行迭代，对每个整数对，计算x[i, j]总和，保存最大值，时间复杂度为$O(n^3)$

```c++
int maxsofar = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        int sum = 0;
        for (int k = i; k <= j; k++) {
            sum += x[k];
            maxsofar = max(maxsofar, sum);
        }
    }
}
```

### 两个平方算法

第一个平方算法注意到，x[i..j]的总和与前面已计算出的总和（x[i..j-1]的总和）密切相关，利用这一关系即可得到算法2a

```c++
int maxsofar = 0;
for (int i = 0; i < n; i++) {
    int sum = 0;
    for (int j = i; j < n; j++) {
        sum += x[j];
        maxsofar = max(maxsofar, sum);
    }
}
```

另一个平方算法时通过访问在外层循环执行之前就已经构建的数据结构的方式在内循环中计算总和。**cumarr中的第i元素包含x[0, i]中各个数的累加和**，所有x[i..j]中各个数的总和可以通过计算cumarr[j]-cumarr[i-1]得到，从而得到算法2b

```c++
cumarr[-1] = 0;
for (int i = 0; i < n; i++) {
    cumarr[i] = cumarr[i - 1] + x[i];
}
int maxsofar = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        sum = cumarr[j] - cumarr[i - 1];
        maxsofar = max(maxsofar, sum);
    }
}
```

### 分治算法

要解决规模为n的问题，可递归的解决两个规模近似为n/2的问题，然后对它们的答案进行合并得到整个问题的答案

最大子向量要么在整个a中，要么在整个b中，要么横跨a和b之间的边界

$|~~~~~~a~~~~~~|~~~~~~b~~~~~~|$

$|~~~~~~|~~~~~m_c~~~~~|~~~~~~|$

我们的分治算法将递归地计算$m_a$和$m_b$，并通过其他方法计算$m_c$，然后返回三者中最大者

我们还需要解决的问题是如何处理小向量以及计算$m_c$

1. 计算小向量，如果只有一个向量，那么最大子向量和为0，即零向量
2. 计算$m_c$，$m_c$在a中的部分是a中包含右边界的最大子向量，在b中的部分是b中包含左边界的最大子向量

```c++
float maxsum3(int l, int u) {
    if (l > u)   /*0个元素*/
        return 0;
    if (l == u)  /*1个元素*/
        return max(0, x[1]);
    m = (l + u) / 2;

    lmax = sum = 0;  /*沿中轴向左求出最大子向量*/
    for (int i = m; i >= l; i--) {
        sum += x[i];
        lmax = max(lmax, sum);
    }
    rmax = sum = 0;  /*沿中轴向右求出最大子向量*/
    for (int i = m + 1; i <= u; i++) {
        sum += x[i];
        rmax = max(rmax, sum);
    }
    /*求出m_a, m_b, m_c中的最大值*/
    return max(lmax + rmax, maxsum3(l, m), maxsum3(m + 1, u));
}
```

```c++
/*调用为*/
answer = maxsum3(0, n - 1);
```

时间复杂度$O(nlogn)$
递推关系为：$T(n) = 2T(n/2) + O(n)$，$T(n)=O(nlogn)$

### 扫描算法（动态规划）

不从头开始计算结束位置为i的最大子向量，而是利用结束位置为i-1的最大子向量进行计算，伪代码如下：

```c++
maxsofar = 0;
maxendinghere = 0;
for i = [0, n)
/*maxendinghere是结束位置为i-1的最大子向量的和，赋值语句将其修改为结束位置为i的最大子向量的和，maxendinghere为中间结果*/
    maxendinghere = max(maxendinghere + x[i], 0);
    maxsofar = max(maxsofar, maxendinghere)
```

几个重要的算法设计技术

- **保存状态，避免重复计算**
- **将信息预处理至数据结构**
- **分治算法**
- **扫描算法**
- **累积**：算法2b使用了一个累积表，cumarr
- **下界**

### 习题

10. 假设我们要查找的是总和最接近0的子向量，而不是具有最大总和的子向量

解决办法：

- 初始化累加数组cum，使得cum[i] = x[0] + ... + x[i]，如果cum[l - 1] = cum[u]，那么子向量cum[l...u]之和就是0，应此可以通过定位cum中最接近的两个元素来找出最接近0的子向量，可以通过排序数组，在$O(nlogn)$时间内完成。

```c++
struct Node{
    int index;
    int value;
};

bool comp(const Node& n1, const Node& n2) {
    return n1.value < n2.value;
}

int get_near_sum(vector<int>& vec) {

    vector<Node> cum;
    Node node0;
    node0.index = 0;
    node0.value = vec[0];
    cum.push_back(node0);
    for (int i = 1; i < vec.size(); i++) {
        Node current;
        current.index = i;
        current.value = cum[i - 1].value + vec[i];
        cum.push_back(current);
    }

    sort(cum.begin(), cum.end(), comp);

    for (int i = 0; i < cum.size(); i++) {
        if (cum[i].value == 0) {
            cout << "idx: 0-" << cum[i].index << endl;
            cout << "min: 0" << endl;
            return 0;
        }
    }

    int minVal = cum[1].value - cum[0].value;
    for (int i = 1; i < cum.size(); i++) {
        int tmp = cum[i].value - cum[i - 1].value;
        if (tmp < minVal) {
            minVal = tmp;
            //如果cum[l - 1] = cum[u]，那么子向量cum[l...u]之和就是0
            cout << "idx: " << cum[i - 1].index + 1<< " " << cum[i].index << endl;
        }
    }
    cout << "min: " << minVal << endl;
}
// 有些特殊情况可能还未考虑
```

不能使用DP是因为总的最优解不能通过子结构的最优解来获得