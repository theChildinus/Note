# 编程珠玑

## 第二章 算法

2.1 三个问题

- A：（二分法）

`给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中一32位整数。`(二分搜索通过重复探索当前范围的中点来定位对象)

1. 在文件中至少存在这样一个数？
    - 32位整数一共有4 294 967 296个这样的数
2. 如果有足够的内存，如何处理？
    - 采用位图技术 使用 536870912个八位字节形成位图表示已经看到的整数
3. 如果内存不足，仅可以用文件来进行处理，如何处理？
    - 从整数的32位表示的角度来看，当我们读入40亿个数（最多，可以分多次读写）把起始位为0的写入到一个文件中，把起始位为1的学如到另一个文件中，这两个文件必然有一个最多包含20亿个数把它作为下一次输入

- B：（递归与抽象）

`将一个n元一维向量向左选旋转i个位置,字符串循环移位,比如abcdef 左移三位,则变成defabc`

```c++
void reverStr(string& str, int begin, int end) {
    while (begin < end) {
        swap(str[begin], str[end]);
        begin++;
        end--;
    }
} 

void rev(string& str, int i) {
    reverStr(str, 0, i - 1);
    reverStr(str, i, str.size() - 1);
    reverStr(str, 0, str.size() - 1);
}
```

- C：（离散化思想）

`给定一个英语字典，找出其中的所有变位词集合,比如abc bca cba互为变位词。任何一种考虑单词中所有单词的排序的方法都注定要失败,原始问题简化为两个子问题：选择标识和集中具有相同标识的单词`

```c++
void addWord(map<string, vector<string> >& dict, string word) {
    string w = word;
    sort(w.begin(), w.end());
    dict[w].push_back(word);
}
void lookup(map<string, vector<string> >& dict, string word) {
    sort(word.begin(), word.end());
    if (dict.count(word) == 0) {
        cout << "no such result" << endl;
        return;
    }

    for (auto item : dict[word]) {
        cout << item << endl;
    }
}
```

### 习题

8. 给定一个n元实数集合，一个实数t和一个整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t。

解决办法：

- 快速排序：时间复杂度nlog(n)
- 堆排序：在这个题目中，我们需要的只是前k个最小元素，时间复杂度为nlog(k)

```c++
vector<int> TopkWithHeap(vector<int>& vec, int k) {
    if (k > vec.size()) {
        return vec;
    }
    priority_queue<int, vector<int>, greater<int> > minHeap;
    for (int i = 0; i < k; i++) {
        minHeap.push(vec[i]);
    }
    for (int i = k; i < vec.size(); i++) {
        if (vec[i] < minHeap.top()) {
            minHeap.pop();
            minHeap.push(vec[i]);
        }
    }
    vector<int> res;
    for (int i = 0; i < k; i++) {
        res.push_back(minHeap.top());
        minHeap.pop();
    }
    for (auto item : res) {
        cout << item << " ";
    }
    cout << endl;
    return res;
}
```

- 作者要求：时间复杂度达到o(n)

`首先在数组中选取一个数centre作为枢纽，将比centre小的数，放到centre的前面将比centre大的数，放到centre的后面。如果此时centre的位置刚好为k，则centre为第k个最小的数；如果此时centre的位置比k前，则第k个最小数一定在centre后面，递归地在其右边寻找；如果此时centre的位置比k后，则第k个最小数一定在centre后面，递归地在其左边寻找`

```c++
int partition(vector<int>& vec, int low, int high) {
    if (vec.empty())
        return -1;
    int flag = vec[low];
    while (low < high) {
        while (low < high && vec[high] >= flag) high--;
        vec[low] = vec[high];
        while (low < high && vec[low] <= flag) low++;
        vec[high] = vec[low];
    }
    vec[low] = flag;
    return low;
}

int getTopk(vector<int>& vec, int k) {
    if (vec.empty())
        return -1;
    int low = 0;
    int high = vec.size() - 1;
    while (high > low) {
        int index = partition(vec, low, high);
        if (k - 1 > index) {
            low = index + 1;
        }
        else if (k - 1 < index) {
            high = index - 1;
        }
        else {
            return index;
        }
    }
}
```

- 位图去重

## 第三章 数据决定程序结构

`程序员在节省空间方面无计可施时，将自己从代码中解放出来，退回起点并集中心力研究数据，常常能有奇效，（数据的）表示形式时程序设计的根本`

- 使用数组重新编写重复代码
- 封装复杂结构
- 尽可能使用高级工具
- 从数据得出程序的结构

## 第四章 编写正确的程序

`编程技巧仅仅是编写正确程序的很小的一部分，大部分内容还是问题定义、算法设计、数据结构的选择`

### 循环不变式

    1. 初始：循环第一次迭代开始之前，我们的描述和假设必须正确
    2. 维护：在某次迭代时正确的，在下次迭代还是正确的
    3. 终止：循环可以终止，并返回正确的结果

### 二分查找值为key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1;
else if (data[mid] < key) left = mid + 1;
else if (data[mid] == key) return mid;
```

- 终止：每次重要没有找到的话，待查区间必定会减少至少一个长度的，所以我们的程序必定会正确结束，不会出现死循环的情况，如果left>right的话，返回-1

```c++
int BinarySerch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid - 1;
        else if (data[mid] < key) left = mid + 1;
        else return mid;
    }
    return -1;
}
```

### 二分查找key第一次出现的下标 可能重复 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1 //1 查找范围缩小了right-mid+1
else if (data[mid] < key) left = mid + 1 //2 查找范围缩小了mid-left+1
else right = mid; //3 相等时，我们要找的是第一次出现的下标，显然第一次出现的下标必然在left-mid之间，查找区间缩小了right-mid
//1,3 可以合并，合并起来可以减少代码量和分支语句，虽然影响搜索的精度，但是不影响结果
```

- 终止：当left=right时，我们的待查区域缩小量始终为：right-mid = right-right = 0，这种情况下会导致死循环，这是我们就要对循环的条件进行修改：
  - left = right - 1时，mid始终等于left，查找范围会缩小，可以正确运行
  - left = right时，mid始终等于left和right，查找范围是0，会不正确终止
  - 根据以上两种情况，我们只要让循环条件变为left < right即可，之后我们对data[left]判断

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (data[mid] < key) left = mid + 1;
        else right = mid;
    }
    return data[left] == key ? left : (data[right] == key ? right : -1);
}
```

### 二分查找key最后一次出现的下标 可能重复 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] > key) right = mid - 1; //1 查找范围缩小了right-mid+1
else if (data[mid] < key) left = mid + 1; //2 查找范围缩小了mid-left+1
else left = mid; //3 相等时，我们要查找的是最后一个元素，先让最后一个key的下标必然在mid-right之间，查找范围缩小mid-right
//同上我们可以合并2，3，减少代码量，我们始终保证了待查元素落在left-right范围内
```

- 终止：当left=right-1 或者left=right时，mid始终等于left，那么对于判断3容易出现死循环，终止条件修正为left< right-1 ,最后对left，right判断

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid - 1;
        else left = mid;
    }
    return data[right] == key ? right : (data[left] == key ? left : -1);
}
```

### 二分查找刚好小于key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if (data[mid] >= key) right = mid - 1; //1 显然小于的话，我们的待查元素必然在left-mid之间
else left = mid; //2 缩小范围是 right-mid+1
```

- 终止：对于1来说，如果left=right-1或left=right会出现死循环，所以修改终止条件为left-right-1

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (data[mid] >= key) right = mid - 1;
        else left = mid;
    }
    return data[right] < key ? right : (data[left] < key ? left : -1);
}
```

### 二分查找刚好大于key的下标 不存在返回-1

- 初始：待查数组范围 left(1)-right(n), 待查元素key如果存在必定在此范围内
- 维护：

```c++
if(data[mid] <= key) left = mid + 1; //1 大于的话，我们的待查元素必然mid-right之间
else right = mid;
```

- 终止：对于情况left==right来说，容易出现死循环的情况，修改循环条件为left < right

```c++
int BinarySearch(vector<int> data, int key) {
    int left = 0;
    int right = data.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (data[mid] > key) right = mid;
        else left = mid + 1;
    }
    return data[left] > key ? left : (data[right] > key ? right : -1);
}
```

### 习题

咖啡罐问题：给定一个盛有一些黑豆和白豆的咖啡罐，以及一些额外的黑豆，重复下面过程，直到罐中仅剩一颗豆子：

- 从罐子中随机取两颗豆子，如果颜色相同，将它们都扔掉，并放入一颗黑豆
- 如果颜色不同，将黑豆扔掉，把白豆放回罐中
- 证明该过程会结束，左后留在罐中的豆子颜色与最初罐中白色豆子和黑色豆子有何函数关系

答：由于每一步都使得豆子减少1粒，所以该过程能够结束。每一步都从拿掉0个或者2个白豆，所以白豆个数的奇偶性不变。因此只有当最初白豆个数是奇数时，最后留下的豆子才可能是白色的

## 第五章 编程小事

### 断言的艺术

脚手架函数是用于输出中间结果的各种函数，通过它们验证程序的每一步的处理结果是否符合预期。

弱断言，仅仅重复了if语句的条件

```c++
else if (x[m] == t) {
    assert(x[m] == t);
    return m;
} else
```

加强的断言，断言其返回值在输入范围内

```c++
assert(0 <= m && m < n && x[m] == t);
```

二分搜索时，断言数组是排序的，assert(sorted())，但是必须注意由于该测试开销较大，我们应该只能在所有的搜索之前进行一次测试，将该测试包含在住主循环之中会导致二分搜索的运行时间正比于nlogn

```c++
int sorted() {
    for (int i = 0; i < n - 1; i++) {
        if (x[i] > x[i - 1])
            return 0;
    }
    return 1;
}
```

## 第六章 程序性能分析

### 优化程序的几个方面

- 算法和数据结构
- 算法调优
- 数据结构重组
- 代码调优
- 硬件

计算机系统中最廉价、最快速且最可靠的元件是根本不存在的

如果仅需要较小的加速，就对效果最佳的层面做改进

如果需要较大的加速，就对多个层面做改进

## 第七章 粗略估计

### 快速检验

1. 和式中各项的纲量必须相同
2. 乘积的纲量是各乘数纲量的乘积

### 经验法则

72法则，假设以年利率r%投资一笔钱y年，如果r*y=72，那么你的投资差不多才会翻倍

$\pi$秒就是一个纳世纪

### 性能估计

耗时的空间分配器，1-12字节的记录要消耗48字节的内存空间，13-28字节的记录要消耗64字节的内存空间

### 安全系数

为了补偿知识局限，在估算实时软件系统性能的时候，以2，4，6的系数来降低对性能的估计，在作出可靠性/可用性保证时，给出一个比我们认为能达到的目标差10倍的结果，在估算规模\开销和时间进度时，给出一个比我们认为能达到的目标差10倍的结果

### Little定律

`系统中物体的平均数量 = 物体离开系统的平均速率 * 每个物体在系统中停留的平均时间`

比如一个地方可以容纳60人，每个人在里面逗留3小时，因此我们进入这个场所的速率大概是每小时20人，现在队伍前面还有20人，这也就意味着我们需要等待大约一小时

`任何事情都应尽量简单，但不宜过于简单`

## 第八章 算法设计技术

### 问题及简单算法

问题：输入为具有n个浮点数的向量x，输出为输入向量的任何连续子向量中的最大和。例如如果输入向量包含下面十个元素

| 31 | -41 | 59 | 26 | -53 | 58 | 97 | -93 | -23 | 84 | 

那么该程序的输出为x[2..6]的总和，即187，当所有数都是正数时，此时最大的子向量就是整个输入向量，当所有数都是负数的时候，总和最大的子向量就是空向量

浅显的程序就是对所有满足 $0<=i<=j<n$ 整数对进行迭代，对每个整数对，计算x[i, j]总和，保存最大值，时间复杂度为$O(n^3)$

```c++
int maxsofar = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        int sum = 0;
        for (int k = i; k <= j; k++) {
            sum += x[k];
            maxsofar = max(maxsofar, sum);
        }
    }
}
```

### 两个平方算法

第一个平方算法注意到，x[i..j]的总和与前面已计算出的总和（x[i..j-1]的总和）密切相关，利用这一关系即可得到算法2a

```c++
int maxsofar = 0;
for (int i = 0; i < n; i++) {
    int sum = 0;
    for (int j = i; j < n; j++) {
        sum += x[j];
        maxsofar = max(maxsofar, sum);
    }
}
```

另一个平方算法时通过访问在外层循环执行之前就已经构建的数据结构的方式在内循环中计算总和。**cumarr中的第i元素包含x[0, i]中各个数的累加和**，所有x[i..j]中各个数的总和可以通过计算cumarr[j]-cumarr[i-1]得到，从而得到算法2b

```c++
cumarr[-1] = 0;
for (int i = 0; i < n; i++) {
    cumarr[i] = cumarr[i - 1] + x[i];
}
int maxsofar = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        sum = cumarr[j] - cumarr[i - 1];
        maxsofar = max(maxsofar, sum);
    }
}
```

### 分治算法

要解决规模为n的问题，可递归的解决两个规模近似为n/2的问题，然后对它们的答案进行合并得到整个问题的答案

最大子向量要么在整个a中，要么在整个b中，要么横跨a和b之间的边界

|$~~~~~~$$m_a$$~~~~~~$|$~~~~~~$$m_b$$~~~~~~$|

|$~~~~~~$|$~~~~~~$$m_c$$~~~~~~$|$~~~~~~$|

我们的分治算法将递归地计算$m_a$和$m_b$，并通过其他方法计算$m_c$，然后返回三者中最大者

我们还需要解决的问题是如何处理小向量以及计算$m_c$

1. 计算小向量，如果只有一个向量，那么最大子向量和为0，即零向量
2. 计算$m_c$，$m_c$在a中的部分是a中包含右边界的最大子向量，在b中的部分是b中包含左边界的最大子向量

```c++
float maxsum3(int l, int u) {
    if (l > u)   /*0个元素*/
        return 0;
    if (l == u)  /*1个元素*/
        return max(0, x[1]);
    m = (l + u) / 2;

    lmax = sum = 0;  /*沿中轴向左求出最大子向量*/
    for (int i = m; i >= l; i--) {
        sum += x[i];
        lmax = max(lmax, sum);
    }
    rmax = sum = 0;  /*沿中轴向右求出最大子向量*/
    for (int i = m + 1; i <= u; i++) {
        sum += x[i];
        rmax = max(rmax, sum);
    }
    /*求出m_a, m_b, m_c中的最大值*/
    return max(lmax + rmax, maxsum3(l, m), maxsum3(m + 1, u));
}
```

```c++
/*调用为*/
answer = maxsum3(0, n - 1);
```

时间复杂度$O(nlogn)$
递推关系为：$T(n) = 2T(n/2) + O(n)$，$T(n)=O(nlogn)$

### 扫描算法（动态规划）

不从头开始计算结束位置为i的最大子向量，而是利用结束位置为i-1的最大子向量进行计算，伪代码如下：

```c++
maxsofar = 0;
maxendinghere = 0;
for i = [0, n)
/*maxendinghere是结束位置为i-1的最大子向量的和，赋值语句将其修改为结束位置为i的最大子向量的和，maxendinghere为中间结果*/
    maxendinghere = max(maxendinghere + x[i], 0);
    maxsofar = max(maxsofar, maxendinghere)
```

几个重要的算法设计技术

- **保存状态，避免重复计算**
- **将信息预处理至数据结构**
- **分治算法**
- **扫描算法**
- **累积**：算法2b使用了一个累积表，cumarr
- **下界**

### 习题

10. 假设我们要查找的是总和最接近0的子向量，而不是具有最大总和的子向量

解决办法：

- 初始化累加数组cum，使得cum[i] = x[0] + ... + x[i]，如果cum[l - 1] = cum[u]，那么子向量cum[l...u]之和就是0，应此可以通过定位cum中最接近的两个元素来找出最接近0的子向量，可以通过排序数组，在$O(nlogn)$时间内完成。

```c++
struct Node{
    int index;
    int value;
};

bool comp(const Node& n1, const Node& n2) {
    return n1.value < n2.value;
}

int get_near_sum(vector<int>& vec) {

    vector<Node> cum;
    Node node0;
    node0.index = 0;
    node0.value = vec[0];
    cum.push_back(node0);
    for (int i = 1; i < vec.size(); i++) {
        Node current;
        current.index = i;
        current.value = cum[i - 1].value + vec[i];
        cum.push_back(current);
    }

    sort(cum.begin(), cum.end(), comp);

    for (int i = 0; i < cum.size(); i++) {
        if (cum[i].value == 0) {
            cout << "idx: 0-" << cum[i].index << endl;
            cout << "min: 0" << endl;
            return 0;
        }
    }

    int minVal = cum[1].value - cum[0].value;
    for (int i = 1; i < cum.size(); i++) {
        int tmp = cum[i].value - cum[i - 1].value;
        if (tmp < minVal) {
            minVal = tmp;
            //如果cum[l - 1] = cum[u]，那么子向量cum[l...u]之和就是0
            cout << "idx: " << cum[i - 1].index + 1<< " " << cum[i].index << endl;
        }
    }
    cout << "min: " << minVal << endl;
}
// 有些特殊情况可能未考虑到
```

不能使用DP是因为总的最优解不能通过子结构的最优解来获得

## 第九章 代码调优

### 急救方案集锦

**整数取模** 

```c++
k = (j + rotdist) % n;
```

c语言的模运算符%开销较大，越100纳秒，正常的算数运算10纳秒

```c++
k = j + rotdist;
if (k >= n) 
    k -= n;
```

`对于现代的体系结构，如果对内存的访问占用了大量的运行时间，那么减少计算时间同样是毫无意义的`

**函数、宏和内敛代码**

c++允许对某一函数进行内敛编译，这就兼具了函数的简洁语义和宏的低廉开销

**顺序搜索**

```c++
int sserach1(t)
    for i = [0, n)
        if x[i] == t
        return i;
    return -1
```

该循环已经很简洁了，但是还可以再进行少许精简，这样的优化大概加速了5%

```c++
int ssearch2(t)
    hold = x[n]
    x[n] = t
    for (i = 0; ; i++)
    // 这里是简化的关键，少了循环中 i<n 的比较
        if (x[i] == t)
            break
    x[n] = hold
    if i == n
        return -1
    else
        return i
```

我们最终的顺序搜索程序将循环展开8次来删除自增，将循环展开有助于避免管道阻塞，减少分支，增加指令级的并行性

```c++
int ssearch3(t)
    x[n] = t
    for (i = 0; ; i += 8)
        if (x[i] == t) { break; }
        if (x[i + 1] == t) { i += 1; break; }
        if (x[i + 2] == t) { i += 2; break; }
        if (x[i + 3] == t) { i += 3; break; }
        if (x[i + 4] == t) { i += 4; break; }
        if (x[i + 5] == t) { i += 5; break; }
        if (x[i + 6] == t) { i += 6; break; }
        if (x[i + 7] == t) { i += 7; break; }
    if (i == n)
        return -1
    else
        return i
```

**计算球面距离**

使用x,y,z坐标表示球面上点的位置，计算该点到集合S中每个点的距离，它到S中某点的距离为三个维度上差值的平方和，这样的系统开销要比计算一个三角函数的开销少很多

### 大手术———二分搜索

二分搜索算法效率很高，对其进行代码调优通常是多余的

#### 原先的二分搜索

```c++
l = 0; u = n - 1
loop
    if l > u
        p = -1; break;
    m = (l + u) / 2;
    case:
        x[m] < t; l = m + 1;
        x[m] == t; p = m; break;
        x[m] > t; u = m - 1;
```

```c++
int binarySearch0(vector<int> x, int key) {
    int l = 0, r = x.size() - 1;
    int m = 0;
    while (true) {
        if (l > r)
            return -1;
        m = (l + r) / 2;
        if (x[m] < key) {
            r = m + 1;
        }
        if (x[m] == key) {
            return m;
        }
        if (x[m] > key) {
            r = m - 1;
        }
    }
}
```

#### 第一次手术

我们假定$n >= 0, x[-1] < t, x[n] >= t$，通过对x[m]与key的比较，不断更新l或r，使得$x[l] < t, x[r] >= t$始终成立，当l+1=m跳出循环时仍然成立，此时看一下r是否为所求下标

在每次循环中，他只对key和x中的元素作一次比较，而原先的程序有时必须比较两次

```c++
int binarySearch1(vector<int> x, int key) {
    int l = -1, r = x.size();
    while (l + 1 ! = r) {
        m = (l + r) / 2;
        if (x[m] < key)
            l = m;
        else
            r = m;
    }
    if (r >= x.size() || x[r] != key) {
        return -1;
    }
    else
        return r;
}
```

#### 第二次手术

假定n=1000，程序我们不使用l，r表示数组的左右边界，而是**使用l+i来表示右边界**，所以就要使得l+i=r，并且我们要求i是2的幂

```c++
int binarySearch2(vector<int> x, int key) {
    int i = 512;
    int l = -1;
    if (x[511] < key) {
        l = 1000 - 512;
    } // 确保初始的搜索范围大小为512
    int next_i;
    while (i != 1) {
        next_i = i / 2;
        if (x[l + next_i] < key) {
            l += next_i;
            i = next_i;
        }
        else {
            i = next_i;
        }
    }
    int p = l + 1;
    if (p > 1000 || x[p] != key) {
        return -1;
    }
    return p;
}
```

优化：

```c++
int binarySearch2_b(vector<int> x, int key) {
    int i = 512;
    int l = -1;
    if (x[511] < key) {
        l = 1000 - 512;
    }
    while (i != 1) {
        i = i / 2;
        if (x[l + i] < key) {
            l += i;
        }
    }
    int p = l + 1;
    if (p > 1000 || x[p] ！= key)
        return -1;

    return p;
}
```

#### 第三次手术

展开整个循环，从而消除了循环控制和i被2除的开销

```c++
int binarySort3(int x[],int key) {
    int i = 512;
    int l = -1;
    if(x[511] < key){
        l=1000 - 512;
    }
    if(x[l + 256] < key)  l += 256;
    if(x[l + 128] < key)  l += 128;
    if(x[l + 64] < key)   l += 64;
    if(x[l + 32] < key)   l += 32;
    if(x[l + 16] < key)   l += 16;
    if(x[l + 8] < key)    l += 8;
    if(x[l + 4] < key)    l += 4;
    if(x[l + 2] < key)    l += 2;
    if(x[l + 1] < key)    l += 1;
//      assert(i == 1 && x[l] < key && x[l + i] >= key);
    int p = l + 1;
    if(p > 1000 || x[p] != key) {
        return -1;
    }
    return p;
}
```

### 原理

**代码调优最重要原理就是尽量少用它**

- 效率的角色
  - 程序的许多性质和效率一样重要，甚至更重要
- 度量工具
  - 性能监视可以帮我们找到程序中的关键区域
- 设计层面
  - 效率问题可以由多种方法来解决，只有在确信没有更好的方法时才考虑代码调优
- 双刃剑
  - 用if替换模运算有时可以使速度加倍，有时却对运动时间没什么影响

### 习题

7. 给定一个非常长的字节序列，如何高效地统计1的个数？

[参考博客 - 求二进制数中1的个数](https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html
)

#### **普通法**

移位加计数

```c++
int BitCount1(unsigned int n) {
    unsigned int count = 0;
    while (n > 0) {
        if ((n & 1) == 1)
            count++;
        n >>= 1;
    }
    return count;
}
```

#### **快速法**

这种方法速度比较快，与n的大小无关，只与n中1的个数有关，原理是不断清除n的二进制表示中最右边的1，同时累加计数

```c++
int BitCount2(unsigned int n) {
    unsigned int count = 0;
    for (count = 0; n; count++) {
        n &= n - 1;
    }
    return count;
}
```

为什么n &= (n – 1)能清除最右边的1呢？

因为从二进制的角度讲，n相当于在n-1的最低位加上1。举个例子，8（1000）= 7（0111）+ 1（0001），所以8 & 7 = （1000）&（0111）= 0（0000），**清除了8最右边的1（其实就是最高位的1，因为8的二进制中只有一个1）**，再比如7（0111）= 6（0110）+ 1（0001），所以7 & 6 = （0111）&（0110）= 6（0110），清除了7的二进制表示中最右边的1（也就是最低位的1）。

#### **查表法**

- 动态建表

```c++
int BitCount3(unsigned int n) {
    //  建表
    unsigned char BitSetTable256[256] = {0};

    // 初始化表
    for (int i = 0; i < 256; i++) {
        BitSetTable256[i] = (i & 1) + BitSetTable256[i / 2];
    }

    unsigned int count = 0;
    unsigned char* p = (unsigned char*) &n;
    count = BitSetTable256[p[0]] + \
            BitSetTable256[p[1]] + \
            BitSetTable256[p[2]] + \
            BitSetTable256[p[3]];

    return count;
}
```

建表的原理，根据奇偶性来分析，对于任意一个正整数n

1. 如果它是偶数，那么n的二进制中1的个数与n/2中1的个数是相同的，比如4和2的二进制中都有一个1，6和3的二进制中都有两个1。**因为n是由n/2左移一位而来，而移位并不会增加1的个数**。

2. 如果n是奇数，那么n的二进制中1的个数是n/2中1的个数+1，比如7的二进制中有三个1，7/2 = 3的二进制中有两个1。**因为当n是奇数时，n相当于n/2左移一位再加1**。

查表的原理

- 对于任意一个32位无符号整数，将其分割为4部分，每部分8bit，对于这四个部分分别求出1的个数，再累加起来即可。而8bit对应2^8 = 256种01组合方式，这也是为什么表的大小为256的原因。

- 注意类型转换的时候，先取到n的地址，然后转换为unsigned char*，这样一个unsigned int（4 bytes）对应四个unsigned char（1 bytes），分别取出来计算即可。以87654321（十六进制）为例，先写成二进制形式-8bit一组，共四组，这四组中1的个数分别为4，4，3，2，所以一共是13个1，如下面所示。

10000111 01100101 01000011 00100001 = 4 + 4 + 3 + 2 = 13

- 静态表 - 4bit

```c++
int BitCount4(unsigned int n) {
    unsigned int table[16] = {
        0, 1, 1, 2,
        1, 2, 2, 3,
        1, 2, 2, 3,
        2, 3, 3, 4
    }

    unsigned int count = 0;
    while (n) {
        count += table[n & 0xf];
        n >>= 4;
    }
    return count;
}
```

- 静态表 - 8bit

```c++
int BitCount7(unsigned int n)
{ 
    unsigned int table[256] = 
    { 
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    }; 

    return table[n &0xff] +
        table[(n >>8) &0xff] +
        table[(n >>16) &0xff] +
        table[(n >>24) &0xff] ;
}
```

- 首先构造一个包含256个元素的表table，table[i]即i中1的个数，这里的i是[0-255]之间任意一个值。然后对于任意一个32bit无符号整数n，我们将其拆分成四个8bit，然后分别求出每个8bit中1的个数，再累加求和即可
- 这里用移位的方法，每次右移8位，并与0xff相与，取得最低位的8bit，累加后继续移位，如此往复，直到n为0。所以对于任意一个32位整数，需要查表4次。
- 以十进制数2882400018为例，其对应的二进制数为10101011110011011110111100010010，对应的四次查表过程如下：加粗表示当前8bit，斜体表示右移后高位补零。

第一次(n & 0xff) 10101011 11001101 11101111 **00010010**

第二次((n >> 8) & 0xff) *00000000* 10101011 11001101 **11101111**

第三次((n >> 16) & 0xff) *00000000 00000000* 10101011 **11001101**

第四次((n >> 24) & 0xff) *00000000 00000000 00000000* **10101011**

可以建立16bit或32bit表，速度会更快

文中还提到了 **平行法**，**完美法**，**位标志法**，**指令法**
